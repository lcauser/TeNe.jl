var documenterSearchIndex = {"docs":
[{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"CollapsedDocStrings = true","category":"page"},{"location":"manual/tensors/#Tensors","page":"Tensors","title":"Tensors","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Pages = [\"tensors.md\"]\nDepth = 3","category":"page"},{"location":"manual/tensors/#Tensor-operations","page":"Tensors","title":"Tensor operations","text":"","category":"section"},{"location":"manual/tensors/#Tensor-contraction","page":"Tensors","title":"Tensor contraction","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Contract two tensors x and y over dimensions cix and ciy with a shared size. This can be done in place with a pre-allocated tensor z using contract!(z, x, y, cix, ciy), or otherwise contract(x, y, cix, ciy). The dimensions cix and ciy can be specified as integers or tuples of integers for contractions over multiple dimensions. Optionally, the tensors used in the contraction can be conjugated using the arguments conjx and conjy. Note that, by default, the result will be stored in the memory cache (using keyword argument tocache). If the contraction is not some intermediate step, and you would like to save the resulting tensor for future use, then use tocache=false.","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"contract!\ncontract","category":"page"},{"location":"manual/tensors/#TeNe.contract!","page":"Tensors","title":"TeNe.contract!","text":"contract!(z, x, y, cix, ciy, [conjx=false, conjy=false])\n\nContract tensors x and y across dimensions cix and ciy, and store the result in z. In-place version of contract.\n\nArguments\n\n- `z`: tensor to store the result.\n- `x`: first tensor to contract.\n- `y': second tensor to contract.\n- `cix`: the dimensions of the first tensor to contract.\n- `ciy`: the dimensions of the second tensor to contract.\n- `conjx::Bool=false`: Take the complex conjugate of argument x?\n- `conjy::Bool=false`: Take the complex conjugate of argument y?\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3, 4);\njulia> y = randn(ComplexF64, 3, 5, 6);\njulia> z = similar(x, (2, 4, 5, 6));\njulia> contract!(z, x, y, 2, 1)\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#TeNe.contract","page":"Tensors","title":"TeNe.contract","text":"contract(x, y, cix, ciy, [conjx=false, conjy=false]; kwargs...)\n\nContract tensors x and y across dimensions cix and ciy, and returns it as z.\n\nArguments\n\n- `x`: first tensor to contract.\n- `y': second tensor to contract.\n- `cix`: the dimensions of the first tensor to contract.\n- `ciy`: the dimensions of the second tensor to contract.\n- `conjx::Bool=false`: Take the complex conjugate of argument x?\n- `conjy::Bool=false`: Take the complex conjugate of argument y?\n\nOptional Keyword Arguments\n\n- `tocache::Bool=true`: store the result in the second level of the cache?\n- `sublevel=:auto`: if stored in cache, at which sublevel? :auto finds non-aliased memory\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3, 4);\njulia> y = randn(ComplexF64, 3, 5, 6);\njulia> z = contract(x, y, 2, 1);\njulia> size(z)\n(2, 4, 5, 6)\n\njulia> x = randn(ComplexF64, 2, 3, 4, 5);\njulia> y = randn(ComplexF64, 6, 5, 2, 7);\njulia> z = contract(x, y, (1, 4), (3, 2));\njulia> size(z)\n(3, 4, 6, 7)\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#Tensor-product","page":"Tensors","title":"Tensor product","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Take the tensor product over two tensors x and y to give a single tensor. This can be done in place with a pre-allocated tensor z using tensorproduct!(z, x, y), or otherwise tensorproduct(x, y). Optionally, the tensors used in the product can be conjugated using the arguments conjx and conjy. Note that, by default, the result will be stored in the memory cache (using keyword argument tocache). If the result is not some intermediate step, and you would like to save the resulting tensor for future use, then use tocache=false.","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"tensorproduct!\ntensorproduct","category":"page"},{"location":"manual/tensors/#TeNe.tensorproduct!","page":"Tensors","title":"TeNe.tensorproduct!","text":"tensorproduct!(z, x, y, [conjx=false, conjy=false])\n\nCompute the tensor product of the two tensors x and y, and store the  result in z. Optionally, do the tensor product using the conjugate of the tensors.\n\nArguments\n\n- `z`: tensor to store the result.\n- `x`: first tensor.\n- `y': second tensor.\n- `conjx::Bool=false`: Take the complex conjugate of argument x?\n- `conjy::Bool=false`: Take the complex conjugate of argument y?\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3);\njulia> y = randn(ComplexF64, 4, 5);\njulia> z = similar(x, (2, 3, 4, 5));\njulia> tensorproduct!(z, x, y);\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#TeNe.tensorproduct","page":"Tensors","title":"TeNe.tensorproduct","text":"tensorproduct(x, y, [conjx=false, conjy=false])\n\nCompute the tensor product of the two tensors x and y, and store the  result in z. Optionally, do the tensor product using the conjugate of the tensors.\n\nArguments\n\n- `x`: first tensor.\n- `y': second tensor.\n- `conjx::Bool=false`: Take the complex conjugate of argument x?\n- `conjy::Bool=false`: Take the complex conjugate of argument y?\n\nOptional Keyword Arguments\n\n- `tocache::Bool=true`: store the result in the second level of the cache?\n- `sublevel=:auto`: if stored in cache, at which sublevel? :auto finds non-aliased memory\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3);\njulia> y = randn(ComplexF64, 4, 5);\njulia> z = tensorproduct(x, y);\njulia> size(z)\n(2, 3, 4, 5)\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#Tensor-trace","page":"Tensors","title":"Tensor trace","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Compute the trace over multiple dimensions cix in a tensor x. This can be done in place with a pre-allocated tensor z using trace!(z, x, cix...), or otherwise trace(x, cix...). Optionally, the tensor used in the trace can be conjugated using the key word argument conj. Note that, by default, the result will be stored in the memory cache (using keyword argument tocache). If the result is not some intermediate step, and you would like to save the resulting tensor for future use, then use tocache=false.","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"trace!\ntrace(x, cix::Int...)","category":"page"},{"location":"manual/tensors/#TeNe.trace!","page":"Tensors","title":"TeNe.trace!","text":"trace!(z, x, cix::Int...; kwargs)\n\nCompute the trace of xover dimensionscix, and store the result inz`. In place version of trace.\n\nOptional Keyword Arguments\n\n- 'conj::Bool=false': take the conjugate?\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3, 4, 3);\njulia> z = similar(x, (2, 4));\njulia> trace!(z, x, (2, 4));\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#TeNe.trace-Tuple{Any, Vararg{Int64, N} where N}","page":"Tensors","title":"TeNe.trace","text":"trace(x, cix::Int...; kwargs)\n\nCompute the trace of x over dimensions cix.\n\nOptional Keyword Arguments\n\n- `conj::Bool=false`: take the conjugate?\n- `tocache::Bool=true`: store the result in the second level of the cache?\n- `sublevel=:auto`: if stored in cache, at which sublevel? :auto finds non-aliased memory\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3, 4, 3);\njulia> y = trace(x, 2, 4);\njulia> size(y)\n(2, 4)\n\n\n\n\n\n","category":"method"},{"location":"manual/tensors/#Permuting-a-single-dimension","page":"Tensors","title":"Permuting a single dimension","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Permute the dimension at position i in tensor x to position j. This can be done in place with a pre-allocated tensor z using permutedim!(z, x, i, j), or otherwise permutedim(x, i, j). Note that, by default, the result will be stored in the memory cache (using keyword argument tocache). If the result is not some intermediate step, and you would like to save the resulting tensor for future use, then use tocache=false.","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"permutedim!\npermutedim","category":"page"},{"location":"manual/tensors/#TeNe.permutedim!","page":"Tensors","title":"TeNe.permutedim!","text":"permutedim!(z, x, i, j; kwargs...)\n\nPermute dimension i to j for tensor x. Store the result in z. In place version of permutedim.\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3, 4, 5);\njulia> z = similar(x, (2, 4, 5, 3));\njulia> permutedims!(z, x, 2, 4);\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#TeNe.permutedim","page":"Tensors","title":"TeNe.permutedim","text":"permutedim(x, i::Int, j::Int; kwargs...)\n\nPermute dimension with position i to position j for tensor x.\n\nOptional Keyword Arguments\n\n- `tocache::Bool=true`: store the result in the second level of the cache?\n- `sublevel=:auto`: if stored in cache, at which sublevel? :auto finds non-aliased memory\n\nExamples\n\njulia> x = randn(ComplexF64, 2, 3, 4, 5);\njulia> x = permutedim(x, 2, 4);\njulia> size(x)\n(2, 4, 5, 3)\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#Combining-and-restoring-dimensions","page":"Tensors","title":"Combining & restoring dimensions","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Dimensions in a tensor can be combined into a single dimension, and restored using a key. This allows us to make efficient use of BLAS and LAPACK routines involving matrix operations. ","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"Combine the dimensions cixs of tensor x. This can be done in place with a pre-allocated tensor z using key = combinedims!(z, x, cixs), or otherwise z, key = combinedims(x, cixs). Note that, by default, the result will be stored in the memory cache (using keyword argument tocache). If the result is not some intermediate step, and you would like to save the resulting tensor for future use, then use tocache=false.","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"combinedims!\ncombinedims","category":"page"},{"location":"manual/tensors/#TeNe.combinedims!","page":"Tensors","title":"TeNe.combinedims!","text":"combinedims!(y, x, cixs)\n\nCombine the dimensions cixs in tensor x, and store the result in y.\n\nExamples\n\njulia> x = randn(ComplexF64, 4, 5, 6, 7);\njulia> y = similar(x, (4, 7, 30));\njulia> key = combinedims!(y, x, (2, 3))\n((2, 3), (5, 6))\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#TeNe.combinedims","page":"Tensors","title":"TeNe.combinedims","text":"combinedims(x, cixs; kwargs...)\n\nCombine the dimensions cixs in tensor x. \n\nReturns the reshaped tensor, along with a key to restore the original permutations.\n\nOptional Keyword Arguments\n\n- `tocache::Bool=true`: store the result in the second level of the cache?\n- `sublevel=:auto`: which sublevel to store in the cache?\n- `return_copy=false`: Return the result in newly allocated memory from the cache?\n  Only necessary if the combined dimensions are the last dimensions of `x`.\n\nExamples\n\njulia> x = randn(ComplexF64, 4, 5, 6, 7);\njulia> y, key = combinedims(x, (2, 3));\njulia> size(y)\n(4, 7, 30)\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"After combining the dimensions, which returns a key, the dimensions of the tensor can be restored. This can be done in place with a pre-allocated tensor y using uncombinedims!(y, x, key), or otherwise y = uncombinedims(y, x, key). Note that, by default, the result will be stored in the memory cache (using keyword argument tocache). If the result is not some intermediate step, and you would like to save the resulting tensor for future use, then use tocache=false.","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"uncombinedims!\nuncombinedims","category":"page"},{"location":"manual/tensors/#TeNe.uncombinedims!","page":"Tensors","title":"TeNe.uncombinedims!","text":"uncombinedims!(y, x, key)\n\nUncombine the end dimensions of x according to the key, and store the result in y.\n\nExamples\n\njulia> x = randn(ComplexF64, 4, 5, 6, 7);\njulia> z, key = combinedims(x, (2, 3));\njulia> y = similar(x);\njulia> isapprox(y, x);\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#TeNe.uncombinedims","page":"Tensors","title":"TeNe.uncombinedims","text":"uncombinedims(x, key; kwargs...)\n\nUncombine the end dimension in tensor x according to the key.\n\nKey arguments\n\n- `tocache::Bool=true`: store the result in the second level of the cache?\n- `sublevel=:auto`: which sublevel to store in the cache?\n- `return_copy=false`: Return the result in newly allocated memory from the cache?\n  Only necessary if the combined dimensions are the last dimensions of `x`.\n\nExamples\n\njulia> x = randn(ComplexF64, 4, 5, 6, 7);\njulia> y, key = combinedims(x, (2, 3));\njulia> z = uncombinedims(y, key);\njulia> size(z)\n(4, 5, 6, 7)\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/#Tensor-factorisations","page":"Tensors","title":"Tensor factorisations","text":"","category":"section"},{"location":"manual/tensors/#Singular-value-decomposition","page":"Tensors","title":"Singular value decomposition","text":"","category":"section"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"The singular value decomposition M = USV is typically applied to a matrix, but can equally be applied to a tensor to split the dimensions into separate tensors. This is done by permuting and reshaping the tensor into a matrix representation and applying the SVD. The dimensions to be contained in V are specified by dims, with U, S, V = tsvd(x, dims).","category":"page"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"tsvd","category":"page"},{"location":"manual/tensors/#TeNe.tsvd","page":"Tensors","title":"TeNe.tsvd","text":"tsvd(x, dims; kwargs...)\ntsvd(x, dim::Int; kwargs...)\n\nComputer a singular value decomposition of tensor x. Seperates the dimensions dims from the remainder.\n\nOptional Keyword Arguments\n\n- `cutoff::Float64=0.0`: Truncation criteria to reduce the bond dimension.\n  Good values range from 1e-8 to 1e-14.\n- `mindim::Int=1`: Mininum dimension for truncated.\n- `maxdim::Int=0`: Maximum bond dimension for truncation. Set to 0 to have\n  no limit.\n\n\n\n\n\n","category":"function"},{"location":"manual/tensors/","page":"Tensors","title":"Tensors","text":"At a later date, we would like to improve the SVD to pre-allocate memory in the cache for calculating the returns (and optional parameters to pre-allocated the memory to restore the results.)","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"CollapsedDocStrings = true","category":"page"},{"location":"manual/mps/#Matrix-product-states","page":"Matrix product states","title":"Matrix product states","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Matrix product states are an ansatz for describing and estimating states of one-dimensional systems. In this package, MPS can be used for a variety of applications, e.g., ground state estimation, simulating dynamics, and quantum circuit calculations. ","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Pages = [\"mps.md\"]\nDepth = 3","category":"page"},{"location":"manual/mps/#Matrix-product-states-(MPS)","page":"Matrix product states","title":"Matrix product states (MPS)","text":"","category":"section"},{"location":"manual/mps/#Initiating-an-MPS","page":"Matrix product states","title":"Initiating an MPS","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"There are many ways to create an MPS, and the method will depend on the problem at hand.","category":"page"},{"location":"manual/mps/#Random-states","page":"Matrix product states","title":"Random states","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"For variational problems, we sometimes recommend initiating an MPS randomly using ψ = randommps(dim, length, bonddim), where dim is the physical dimension of the lattice, length is the number of sites in the lattice, and bonddim is the bond dimension of the MPS.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"randommps","category":"page"},{"location":"manual/mps/#TeNe.randommps","page":"Matrix product states","title":"TeNe.randommps","text":"randommps(dim::Int, length::Int, bonddim::Int)\n\nCreate an MPS with dimensions dim, size length and bond dimension bonddim, with random tensors.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensors.\n\n\n\n\n\n","category":"function"},{"location":"manual/mps/#Product-states","page":"Matrix product states","title":"Product states","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"An alternative option is to initalise the MPS is a state with known desirable properties.  This can be done in a few ways. The simplest way is to just provide a translationally invariant tensor A for the MPS (with bond dimension one), ψ = productmps(N, A).","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"productmps(N::Int, A::Q) where {Q<:AbstractArray}","category":"page"},{"location":"manual/mps/#TeNe.productmps-Union{Tuple{Q}, Tuple{Int64, Q}} where Q<:AbstractArray","page":"Matrix product states","title":"TeNe.productmps","text":"productmps(N::Int, A<:AbstractArray; kwargs...)\n\nCreate a product MPS of size N, composed of array A.  A can be a vector or rank-3 tensor.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensors.\n- `normalise::Bool=false`: Normalise the MPS after creating it?\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Alternatively, we can use the LatticeTypes interface to write a product state.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"productmps(lt::LatticeTypes, states::AbstractVector{String})","category":"page"},{"location":"manual/mps/#TeNe.productmps-Tuple{LatticeTypes, AbstractVector{String}}","page":"Matrix product states","title":"TeNe.productmps","text":"productmps(lt::LatticeTypes, states::AbstractVector{String})\n\nCreate an MPS from a string of states.\n\nExample\n\njulia> lt = Qubits();\njulia> ψ = productmps(lt, [\"up\" for _ = 1:20]);\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#From-StateVectors","page":"Matrix product states","title":"From StateVectors","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"If you need to write an MPS using some known StateVector, you can call MPS(ψ::StateVector).","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"MPS(::GStateTensor{1})","category":"page"},{"location":"manual/mps/#TeNe.MPS-Tuple{GStateTensor{1, T} where T<:AbstractArray}","page":"Matrix product states","title":"TeNe.MPS","text":"MPS(ψ::StateVector; kwargs...)\n\nWrite a StateVector as a MPS.\n\nOptional Keyword Arguments\n\n- `cutoff::Float64=0.0`: Truncation criteria to reduce the bond dimension.\nGood values range from 1e-8 to 1e-14.\n- `mindim::Int=1`: Minimum dimension for the truncation.\n- `maxdim::Int=0`: Maximum bond dimension for truncation. Set to 0 to have\nno limit.\n\nExamples\n\njulia> ψ = randomsv(2, 10);\njulia> ψ = MPS(ψ; cutoff=1e-12);\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Properties-of-an-MPS","page":"Matrix product states","title":"Properties of an MPS","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"TeNe.rank(::GMPS)\ndim(::GMPS)\ncenter(::GMPS)\nbonddim(::GMPS, ::Int)\nmaxbonddim(::GMPS)\nnorm(::GMPS)\nentropy(::MPS, ::Int)","category":"page"},{"location":"manual/mps/#LinearAlgebra.rank-Tuple{GMPS}","page":"Matrix product states","title":"LinearAlgebra.rank","text":"rank(::GStateTensor)\n\nReturns the rank of a state tensor.\n\n\n\n\n\nrank(::GMPS)\n\nReturns the rank of an MPS object.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#TeNe.dim-Tuple{GMPS}","page":"Matrix product states","title":"TeNe.dim","text":"dim(ψ::GMPS, [which::Int, site::Int])\n\nThe size of the physical dimensions in a GMPS. Returns 0 for heterogeneous  systems (i.e. an invariant physical dimension). The axis and the lattice site can also be specified.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#TeNe.center-Tuple{GMPS}","page":"Matrix product states","title":"TeNe.center","text":"center(::GMPS)\n\nThe orthogonal center of an MPS. Returns 0 if nothing is set.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#TeNe.bonddim-Tuple{GMPS, Int64}","page":"Matrix product states","title":"TeNe.bonddim","text":"bonddim(::GMPS, idx::Int)\n\nReturn the bond dimension size between idx and idx + 1. Returns nothing if out of range.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#TeNe.maxbonddim-Tuple{GMPS}","page":"Matrix product states","title":"TeNe.maxbonddim","text":"maxbonddim(::GMPS)\n\nCalculate the maximum bond dimension within an GMPS.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#LinearAlgebra.norm-Tuple{GMPS}","page":"Matrix product states","title":"LinearAlgebra.norm","text":"norm(ψ::GMPS)\n\nCalculate the norm of an GMPS.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#TeNe.entropy-Tuple{MPS, Int64}","page":"Matrix product states","title":"TeNe.entropy","text":"entropy(ψ::MPS, site::Int)\n\nCalculate the entanglement entropy of an MPS ψ between sites i and i+1.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Manipulations-of-an-MPS","page":"Matrix product states","title":"Manipulations of an MPS","text":"","category":"section"},{"location":"manual/mps/#Normalization","page":"Matrix product states","title":"Normalization","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"normalize!(::GMPS)","category":"page"},{"location":"manual/mps/#LinearAlgebra.normalize!-Tuple{GMPS}","page":"Matrix product states","title":"LinearAlgebra.normalize!","text":"normalize!(ψ::GMPS)\n\nNormalize a GMPS.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Canonical-center","page":"Matrix product states","title":"Canonical center","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"An important property of MPS is that they can be brought into a canonical representation, allowing for better conditioned calculations and simplifications in many MPS algorithms. The canonical center of an MPS ψ is easily moved to idx using movecenter!(ψ, idx). This also allows for dynamic truncation of the MPS, using keyword arguments such as maxdim or cutoff.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"movecenter!(ψ::GMPS, idx::Int)","category":"page"},{"location":"manual/mps/#TeNe.movecenter!-Tuple{GMPS, Int64}","page":"Matrix product states","title":"TeNe.movecenter!","text":"movecenter!(ψ::GMPS, idx::Int; kwargs...)\n\nMove the orthogonal center of an GMPS ψ to idx.\n\nOptional Keyword Arguments\n\n- `cutoff::Float64=0.0`: Truncation criteria to reduce the bond dimension.\n  Good values range from 1e-8 to 1e-14.\n- `mindim::Int=1`: Minimum dimension for the truncation.\n- `maxdim::Int=0`: Maximum bond dimension for truncation. Set to 0 to have\n  no limit.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Truncations","page":"Matrix product states","title":"Truncations","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"The bond dimension of the MPS controls its accuracy. A larger bond dimension has a higher capacity for precision, but also increases the computational cost of algorithms. To reduce the bond dimension (and sacrificing as little accuracy as possible), one can truncate the MPS.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"truncate!(::GMPS)","category":"page"},{"location":"manual/mps/#TeNe.truncate!-Tuple{GMPS}","page":"Matrix product states","title":"TeNe.truncate!","text":"truncate!(ψ::GMPS; kwargs...)\n\nTruncate the bond dimension of a GMPS ψ.\n\nOptional Keyword Arguments\n\n- `cutoff::Float64=0.0`: Truncation criteria to reduce the bond dimension.\nGood values range from 1e-8 to 1e-14.\n- `mindim::Int=1`: Minimum dimension for the truncation.\n- `maxdim::Int=0`: Maximum bond dimension for truncation. Set to 0 to have\nno limit.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Inner-products","page":"Matrix product states","title":"Inner products","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Some linear algebra operations such as the inner product are easy to calculate for MPS.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"inner(ψ::MPS, ϕ::MPS)","category":"page"},{"location":"manual/mps/#TeNe.inner-Tuple{MPS, MPS}","page":"Matrix product states","title":"TeNe.inner","text":"inner(ψ::MPS, ϕ::MPS)\ndot(ψ::MPS, ϕ::MPS)\n*(ψ::MPS, ϕ::MPS)\n\nCalculate the inner product of two MPSs ψ and ϕ.\n\nExamples\n\njulia> ψ = productmps(10, [1, 1]);\njulia> ϕ = productmps(10, [1, 0]);\njulia> ϕ * ψ\n1\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Sampling-an-MPS","page":"Matrix product states","title":"Sampling an MPS","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"By considering an MPS to be a wavefunction from quantum mechanics (we sometimes call this a Born machine in a classical context), we are able to sample it exactly.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"sample(::MPS)","category":"page"},{"location":"manual/mps/#TeNe.sample-Tuple{MPS}","page":"Matrix product states","title":"TeNe.sample","text":"sample(ψ::MPS)\n\nSample the MPS ψ with the interpretation that it is a wavefunction (or Born ansatz).\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Matrix-product-operators-(MPO)","page":"Matrix product states","title":"Matrix product operators (MPO)","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Just as a wavefunction, or state vector, can be represented as an MPS, an operator can be represented by a matrix product operator.","category":"page"},{"location":"manual/mps/#Initiating-an-MPO","page":"Matrix product states","title":"Initiating an MPO","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Like the MPS, an MPO can be initiated randomly or as a product operator. It can also be initiated from some StateOperator.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"randommpo\nproductmpo(N::Int, A::AbstractArray; T::Type=ComplexF64)\nMPO(::GStateTensor{2})","category":"page"},{"location":"manual/mps/#TeNe.randommpo","page":"Matrix product states","title":"TeNe.randommpo","text":"randommpo(dim::Int, length::Int, bonddim::Int; kwargs...)\n\nCreate an MPO with dimensions dim, size length and bond dimension bonddim, with random tensors.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensors.\n\n\n\n\n\n","category":"function"},{"location":"manual/mps/#TeNe.productmpo-Tuple{Int64, AbstractArray}","page":"Matrix product states","title":"TeNe.productmpo","text":"productmpo(N::Int, A::AbstractArray; kwargs...)\n\nCreate a product MPO of size N, composed of array A.  A can be a matrix or rank-4 tensor.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensors.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#TeNe.MPO-Tuple{GStateTensor{2, T} where T<:AbstractArray}","page":"Matrix product states","title":"TeNe.MPO","text":"MPO(O::StateOperator; kwargs...)\n\nWrite a StateOperator as a MPO.\n\nOptional Keyword Arguments\n\n- `cutoff::Float64=0.0`: Truncation criteria to reduce the bond dimension.\nGood values range from 1e-8 to 1e-14.\n- `mindim::Int=1`: Minimum dimension for the truncation.\n- `maxdim::Int=0`: Maximum bond dimension for truncation. Set to 0 to have\nno limit.\n\nExamples\n\njulia> ψ = randomsv(2, 10);\njulia> ψ = MPS(ψ; cutoff=1e-12);\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Alternatively, we can use the LatticeTypes interface to write an operator.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"productmpo(lt::LatticeTypes, ops::AbstractVector{String})","category":"page"},{"location":"manual/mps/#TeNe.productmpo-Tuple{LatticeTypes, AbstractVector{String}}","page":"Matrix product states","title":"TeNe.productmpo","text":"productmpo(lt::LatticeTypes, ops::AbstractVector{String})\n\nCreate an MPO from a string of operators.\n\nExample\n\njulia> lt = Qubits();\njulia> O = productmpo(lt, [\"x\" for _ = 1:20]);\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Construct-an-MPO-from-an-operator-list","page":"Matrix product states","title":"Construct an MPO from an operator list","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"A more powerful option is to write an operator as an OpList, and then use the MPO(::OpList) function to automatically find an exact MPO representation.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"MPO(::OpList)","category":"page"},{"location":"manual/mps/#TeNe.MPO-Tuple{OpList}","page":"Matrix product states","title":"TeNe.MPO","text":"MPO(H::OpList; kwargs...)\n\nCreate an exact MPO representation from an OpList.\n\nOptional Keyword Arguments\n\n- `cutoff::Float64=1.0e-12`: Truncation criteria to reduce the bond dimension.\nGood values range from 1e-8 to 1e-14.\n- `mindim::Int=1`: Minimum dimension for the truncation.\n- `maxdim::Int=0`: Maximum bond dimension for truncation. Set to 0 to have\nno limit.\n\nExamples\n\njulia> lt = Qubits();\njulia> H = OpList(lt, 20);\njulia> for i = 1:20 add!(H, \"x\", i) end;\njulia> for i = 1:19 add!(H, [\"z\", \"z\"], [i, i+1]) end;\njulia> H = MPO(H);\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Products","page":"Matrix product states","title":"Products","text":"","category":"section"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"The expectation value of a string of MPOs with respect to some MPSs can be calculated exactly. The below can be done with many MPOs.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"inner(ψ::MPS, O::MPO, ϕ::MPS)","category":"page"},{"location":"manual/mps/#TeNe.inner-Tuple{MPS, MPO, MPS}","page":"Matrix product states","title":"TeNe.inner","text":"inner(ψ::MPS, O::MPO, ϕ::MPS)\ninner(ψ::MPS, O1::MPO, O2::MPO, ϕ::MPS)\n\nCalculate the expectation of a string of operators Os with respect to MPSs ψ and ϕ.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"Similarly, the trace of a string of MPOs can be calculated.","category":"page"},{"location":"manual/mps/","page":"Matrix product states","title":"Matrix product states","text":"trace(Os::MPO...)","category":"page"},{"location":"manual/mps/#TeNe.trace-Tuple{Vararg{MPO, N} where N}","page":"Matrix product states","title":"TeNe.trace","text":"trace(Os::MPO...)\n\nCompute the trace of the product of many MPOs.\n\n\n\n\n\n","category":"method"},{"location":"manual/mps/#Advanced-usage:-Generalised-matrix-product-states-(GMPS)","page":"Matrix product states","title":"Advanced usage: Generalised matrix product states (GMPS)","text":"","category":"section"},{"location":"examples/dmrg/#Density-matrix-renormalization-group-(DMRG)","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"","category":"section"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"The most profound and impactful tensor-network based algorithm is the much celebrated DMRG method, most-commonly used for estimating the ground-state properties of a one-dimensional quantum Hamiltonian. The idea is to estimate the ground state by a matrix product state (MPS) ketpsi with bond dimension chi, and update the tensors in the MPS one-by-one until the ground state energy has converged. In practice, we construct the Hamiltonian hatH as an exact matrix product operator (MPO), and then the energy can be written as ","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"    E = fracbraketpsi  hatH  psibraketpsi  psi","category":"page"},{"location":"examples/dmrg/#Constructing-the-MPO","page":"Density-matrix renormalization group (DMRG)","title":"Constructing the MPO","text":"","category":"section"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"Finding the MPO for hatH is not always an easy task. TeNe is able to construct the MPO for hatH automatically using a simple interface.  Below, we create the Hamiltonian for a transverse-field Ising model","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"    hatH = -hsum_j=1^N hatX_i - J sum_j=1^N-1 hatZ_jhatZ_j+1","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"with h = 10 and J = 10.","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"N = 20\nqu = Qubits()\nH = OpList(qu, N)\nfor j = 1:N\n    add!(H, \"x\", j, -1.0)\nend\nfor j = 1:N-1\n    add!(H, [\"z\", \"z\"], [j, j+1], -1.0)\nend\nH = MPO(H)","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"The Qubits() function creates a LatticeType that stores all the key information for qubits, such as different local states (e.g. the \"up\" and \"down\" state), and operators (such as \"x\" or \"z\"). Then, we create an operator list for N=20 qubits, passing through the qubits type so that it knows how to  identify operators. We then add the terms to the list like an equation, and convert it to an MPO.","category":"page"},{"location":"examples/dmrg/#Finding-the-ground-state","page":"Density-matrix renormalization group (DMRG)","title":"Finding the ground state","text":"","category":"section"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"To find the ground state, we want to call the DMRG algorithm. We must first have some initial MPS guess, which we'll choose to be random ψ = randommps(2, N, 1), which initalises the MPS with bond dimension chi=1. This is all we need to call the DMRG algorithm.","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"ψ = randommps(2, N, 1)\nenergy, optim = dmrg(ψ, H; cutoff=1e-12, maxdim=16, maxsweeps=30)","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"There are many keyword arguments you can specify to control the hyperparameters for the method, and we recommend to look at the manual. However, we will list some important ones here:","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"cutoff: The bond dimension of the MPS is controlled by a singular value decomposition with some error tolerance. The cutoff is this tolerance: large values will give a smaller bond dimension (and is thus quicker), but is less precise. On the other hand, a small value gives a high-precision result, but can be slow. Some good values are in the range 10^-8 to 10^-16.\nmaxdim: The maximum bond dimension for the algorithm. Setting maxdim=0 means there is no limit on the bond dimension.\nmaxsweeps: The maximum number of iterations to do.\nminsweeps: The minumum number of iterations to run.","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"A strategy we suggest to use the algorithm with a large maxdim, but use the cutoff to control the bond dimension, on a scheduele from large-to-small.","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"ψ = randommps(2, N, 1)\nenergy, optim = dmrg(ψ, H; cutoff=1e-6, maxdim=512, maxsweeps=10)\nsweep!(optim, 10; cutoff=1e-8)\nsweep!(optim, 10; cutoff=1e-10)\nsweep!(optim, 10; cutoff=1e-12)","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"Notice that we can continue to do iterations using DMRG using the optimiser optim: the 10 is the number of (maximum) number of iterations to do, and the hyperparameters can be changed using key arguments. The output should look something like :","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"iter=1, objective=-2.44896927E+01, maxbonddim=2\niter=2, objective=-2.50832673E+01, maxbonddim=4 \niter=3, objective=-2.51074298E+01, maxbonddim=6\niter=4, objective=-2.51077236E+01, maxbonddim=5\niter=5, objective=-2.51077322E+01, maxbonddim=5\niter=6, objective=-2.51077961E+01, maxbonddim=7\niter=7, objective=-2.51077966E+01, maxbonddim=8\niter=8, objective=-2.51077966E+01, maxbonddim=8\niter=9, objective=-2.51077971E+01, maxbonddim=10\niter=10, objective=-2.51077971E+01, maxbonddim=10\niter=11, objective=-2.51077971E+01, maxbonddim=14 \niter=12, objective=-2.51077971E+01, maxbonddim=14 ","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"It is clear that at this point, reducing the cutoff any further gives very minor improvement to the ground state energy.","category":"page"},{"location":"examples/dmrg/#Measuring-observables","page":"Density-matrix renormalization group (DMRG)","title":"Measuring observables","text":"","category":"section"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"We now have the ground state and the ground state energy, but these alone are not all that interesting.  What we would really like to do is measure he properties of the ground state, such as the magnetisations hatX_j and hatZ_jhatZ_j+1.","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"xs = OpList(qu, N)\nfor j = 1:N\n    add!(xs, \"x\", j)\nend\nxs = real(inner(ψ, xs, ψ))\n\nzs = OpList(qu, N)\nfor j = 1:N-1\n    add!(zs, [\"z\", \"z\"], [j, j+1])\nend\nzs = real(inner(ψ, zs, ψ))","category":"page"},{"location":"examples/dmrg/#Finding-excited-states","page":"Density-matrix renormalization group (DMRG)","title":"Finding excited states","text":"","category":"section"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"While DMRG is particularly well suited to extremal eigenstates, it can be used reasonably well to estimate the low-lying excited states. This is done by simply adding the (outer product of the) state ψ to our Hamiltonian.","category":"page"},{"location":"examples/dmrg/","page":"Density-matrix renormalization group (DMRG)","title":"Density-matrix renormalization group (DMRG)","text":"ψ′ = randommps(2, N, 1)\nenergy, optim = dmrg(ψ′, H, ψ; cutoff=1e-12, maxdim=128, maxsweeps=30)","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"CollapsedDocStrings = true","category":"page"},{"location":"manual/statetensors/#State-tensors","page":"State tensors","title":"State tensors","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"State tensors are full-rank tensorial objects for describing tensors of a many-body system, e.g., wavefunctions for lattice systems.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"Pages = [\"statetensors.md\"]\nDepth = 3","category":"page"},{"location":"manual/statetensors/#Vectors","page":"State tensors","title":"Vectors","text":"","category":"section"},{"location":"manual/statetensors/#Initiating-a-state-vector","page":"State tensors","title":"Initiating a state vector","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"There are many ways to initialise a state. For variational methods, a popular choice is to initiate it randomly, which can be achieved using randomsv(dim, length) for physical dimension dim and length lattice sites.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"randomsv(::Int, ::Int)","category":"page"},{"location":"manual/statetensors/#TeNe.randomsv-Tuple{Int64, Int64}","page":"State tensors","title":"TeNe.randomsv","text":"randomsv(dim::Int, length::Int)\nrandomstatevector(dim::Int, length::Int)\n\nCreate a random state vector with dimensions dim, size length.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensors.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"Alternatively, you can initalise it as a mean field state.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"productsv(::Int, ::AbstractVector)","category":"page"},{"location":"manual/statetensors/#TeNe.productsv-Tuple{Int64, AbstractVector{T} where T}","page":"State tensors","title":"TeNe.productsv","text":"productsv(dim::Int, A::AbstractVector)\nproductstatevector(dim::Int, A::AbstractVector)\n\nCreate a product state vector with length length and local state A.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensors.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"Similarly, you can do this using the LatticeTypes feature. For example, initalise a lattice for Qubits, lt = Qubits() and then use ψ = productsv(lt, [\"up\" for _ = 1:6]).","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"productsv(::LatticeTypes, ::AbstractVector{String})","category":"page"},{"location":"manual/statetensors/#TeNe.productsv-Tuple{LatticeTypes, AbstractVector{String}}","page":"State tensors","title":"TeNe.productsv","text":"productsv(lt::LatticeTypes, states::AbstractVector{String})\nproductstatevector(lt::LatticeTypes, states::AbstractVector{String})\n\nCreate a product state from a string of state names.\n\nExample\n\njulia> lt = Qubits();\njulia> ψ = productsv(lt, [\"up\" for _ = 1:6]);\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Properties-of-state-vectors","page":"State tensors","title":"Properties of state vectors","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"rank(::GStateTensor)\ndim(::GStateTensor, ::Int, ::Int)\nlength(::GStateTensor)\nnorm(::GStateTensor)\nentropy(::StateVector, ::Int)\nentropy(::StateVector, ::Any)","category":"page"},{"location":"manual/statetensors/#LinearAlgebra.rank-Tuple{GStateTensor}","page":"State tensors","title":"LinearAlgebra.rank","text":"rank(::GStateTensor)\n\nReturns the rank of a state tensor.\n\n\n\n\n\nrank(::GMPS)\n\nReturns the rank of an MPS object.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#TeNe.dim-Tuple{GStateTensor, Int64, Int64}","page":"State tensors","title":"TeNe.dim","text":"dim(ψ::GStateTensor, [which::Int, site::Int])\n\nReturn the physical dimension of a StateTensor. The axis can be specified using which, and furthermore the site. Returns 0 for heterogeneous systems.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Base.length-Tuple{GStateTensor}","page":"State tensors","title":"Base.length","text":"Base.length(::GStateTensor)\n\nThe length of a state tensor.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#LinearAlgebra.norm-Tuple{GStateTensor}","page":"State tensors","title":"LinearAlgebra.norm","text":"norm(ψ::GStateTensor)\n\nCalculate the norm of a state tensor.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#TeNe.entropy-Tuple{StateVector, Int64}","page":"State tensors","title":"TeNe.entropy","text":"entropy(ψ::StateVector, site::Int)\n\nCalcualte the bipartition entanglement entropy between sites site and site+1 for a StateVector ψ.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#TeNe.entropy-Tuple{StateVector, Any}","page":"State tensors","title":"TeNe.entropy","text":"entropy(ψ::StateVector, sites)\n\nCalcualte the bipartition entanglement entropy between two partitions, one with sites and the other with the remaining sites for StateVector ψ.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Manipulations-of-state-vectors","page":"State tensors","title":"Manipulations of state vectors","text":"","category":"section"},{"location":"manual/statetensors/#Normalization","page":"State tensors","title":"Normalization","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"normalize!(::GStateTensor)","category":"page"},{"location":"manual/statetensors/#LinearAlgebra.normalize!-Tuple{GStateTensor}","page":"State tensors","title":"LinearAlgebra.normalize!","text":"normalize!(ψ::GStateTensor)\n\nNormalize a state tensor.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Exponentiation","page":"State tensors","title":"Exponentiation","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"exp(O::StateOperator)","category":"page"},{"location":"manual/statetensors/#Base.exp-Tuple{StateOperator}","page":"State tensors","title":"Base.exp","text":"exp(O::StateOperator; kwargs...)\n\nExponentiate a StateOperator.\n\nOptional Keyword Arguments\n\n- `prefactor=1.0`: Multiply the StateOperator by some value before the exponetiation.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Inner-products","page":"State tensors","title":"Inner products","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"inner(::StateVector, ::StateVector)","category":"page"},{"location":"manual/statetensors/#TeNe.inner-Tuple{StateVector, StateVector}","page":"State tensors","title":"TeNe.inner","text":"inner(ψ::StateVector, ϕ::StateVector)\ndot(ψ::StateVector, ϕ::StateVector)\n*(ψ::StateVector, ϕ::StateVector)\n\nCalculate the inner product of two StateVectors ψ and ϕ.\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Sampling-a-state-vector","page":"State tensors","title":"Sampling a state vector","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"sample(::StateVector)","category":"page"},{"location":"manual/statetensors/#TeNe.sample-Tuple{StateVector}","page":"State tensors","title":"TeNe.sample","text":"sample(ψ::MPS)\n\nSample the StateVector ψ with the interpretation that it is a wavefunction (or Born ansatz).\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Operators","page":"State tensors","title":"Operators","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"Operators, such as the Hamiltonian of a quantum many-body system, or more generally a matrix can be represented by a StateOperator.","category":"page"},{"location":"manual/statetensors/#Initiating-an-operator","page":"State tensors","title":"Initiating an operator","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"Like a StateVector, we can initalise a StateOperator randomly or as a product state.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"randomso\nproductso(::Int, ::AbstractMatrix)","category":"page"},{"location":"manual/statetensors/#TeNe.randomso","page":"State tensors","title":"TeNe.randomso","text":"randomso(dim::Int, length::Int; kwargs...)\nrandomstateoperator(dim::Int, length::Int; kwargs...)\n\nCreate a state operator with physical dimensions dim and length sites.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensor.\n\nExamples\n\njulia> O = randomso(2, 10);\n\n\n\n\n\n","category":"function"},{"location":"manual/statetensors/#TeNe.productso-Tuple{Int64, AbstractMatrix{T} where T}","page":"State tensors","title":"TeNe.productso","text":"productso(N::Int, A::AbstractMatrix; kwargs...)\nproductstateoperator(N::Int, A::AbstractMatrix; kwargs...)\n\nCreate a state operator as a product state with size N, and composed of array A.\n\nOptional Keyword Arguments\n\n- `T::Type=ComplexF64`: The element type for the tensor.\n\nExamples\n\njulia> O = productso(10, [1 0; 0 1]);\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Construct-an-operator-from-a-list","page":"State tensors","title":"Construct an operator from a list","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"We can also use the LatticeTypes interface to initalise as a product of a string of operators...","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"StateOperator(::OpList)","category":"page"},{"location":"manual/statetensors/#TeNe.StateOperator-Tuple{OpList}","page":"State tensors","title":"TeNe.StateOperator","text":"StateOperator(ops::OpList)\n\nCreate a StateOperator from an OpList.\n\nExamples\n\njulia> lt = Qubits();\njulia> H = OpList(lt, 10);\njulia> for i = 1:10 add!(H, \"x\", i) end;\njulia> for i = 1:9 add!(H, [\"z\", \"z\"], [i, i+1]) end;\njulia> H = StateOperator(H);\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/#Products","page":"State tensors","title":"Products","text":"","category":"section"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"A StateVector or a StateOperator can be multiplied by a StateOperator.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"applyso","category":"page"},{"location":"manual/statetensors/#TeNe.applyso","page":"State tensors","title":"TeNe.applyso","text":"applyso(O::StateOperator, ψ::StateVector)\napplyso(ψ::StateVector, O::StateOperator)\n*(O::StateOperator, ψ::StateVector)\n*(ψ::StateVector, O::StateOperator)\n\nMultiply the StateOperator O to the StateVector ψ.\n\nExamples\n\njulia> O = productso(10, [0 1; 1 0]);\njulia> ψ = productsv(10, [1, 0]);\njulia> ϕ = O * ψ;\n\n\n\n\n\napplyso(O1::StateOperator, O2::StateOperator)\n\nCalculate the product of two StateOperators, O1 and O2.\n\nExamples\n\njulia> O1 = productso(10, [0 1; 1 0]);\njulia> O2 = productso(10, [0 1im; -1im 0]);\njulia> O = O1 * O2;\n\n\n\n\n\n","category":"function"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"This can be done in-place, either so store the result in an existing StateVector ϕ, or to replace ψ. In the case of a StateOperator-StateOperator multiplication, the StateOperator for the result must be specified.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"applyso!","category":"page"},{"location":"manual/statetensors/#TeNe.applyso!","page":"State tensors","title":"TeNe.applyso!","text":"applyso!(ϕ::StateVector, O::StateOperator, ψ::StateVector)\napplyso!(ϕ::StateVector, ψ::StateVector, O::StateOperator)\n\nMultiply the StateOperator O to the StateVector ψ, and store the result in ϕ.\n\nExamples\n\njulia> O = productso(10, [0 1; 1 0]);\njulia> ψ = productsv(10, [1, 0]);\njulia> ϕ = StateVector(2, 10);\njulia> applyso!(ϕ, O, ψ);\n\n\n\n\n\napplyso!(O::StateOperator, O1::StateOperator, O2::StateOperator)\n\nCalculate the product of two StateOperators, O1 and O2. Store the result  in StateOperator O.\n\nExamples\n\njulia> O1 = productso(10, [0 1; 1 0]);\njulia> O2 = productso(10, [0 1im; -1im 0]);\njulia> O = StateOperator(2, 10);\njulia> applyso!(O, O1, O2);\n\n\n\n\n\n","category":"function"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"The expectation value of operators (or a string of operators) can be calculated in the following way.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"inner(::StateVector, ::StateOperator, ::StateVector)","category":"page"},{"location":"manual/statetensors/#TeNe.inner-Tuple{StateVector, StateOperator, StateVector}","page":"State tensors","title":"TeNe.inner","text":"inner(ψ::StateVector, O::StateOperator, ϕ::StateVector)\ninner(ψ::StateVector, O1::StateOperator, O2::MPO, ϕ::StateVector)\n\nCalculate the expectation of a string of StateOperators Os with respect to StateVectors ψ and ϕ.\n\nExamples\n\njulia> ψ = randomsv(2, 10);\njulia> O = productso(10, [0 1; 1 0]);\njulia> inner(ψ, O, O, ψ)\n1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"The trace of an operator (or a string of operators) can be computed in the following way.","category":"page"},{"location":"manual/statetensors/","page":"State tensors","title":"State tensors","text":"trace(::StateOperator...)","category":"page"},{"location":"manual/statetensors/#TeNe.trace-Tuple{Vararg{StateOperator, N} where N}","page":"State tensors","title":"TeNe.trace","text":"trace(Os::StateOperator...)\n\nCompute the trace of a string of StateOperators.\n\nExamples\n\njulia> O = productso(10, [0 1; 1 0]);\njulia> trace(O, O)\n1024.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"#TeNe.jl-Documentation","page":"Introduction","title":"TeNe.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TeNe.jl is a Julia package for running tensor network calculations. Please note that it is currently in development, but with rapid progress! A list of some of the features it current includes are","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tensor functionality (e.g. tensor contractions, tensor products) with memory caching to reduce the amount of allocations needed.\nA natural syntax for implementing common and fundamental tensor network operations, e.g., contracting one tensor network with another using syntax such as ψ * ψ, or inner(ψ, ψ).\nHigh-level interfaces for dealing with physical systems, such as automatic MPO contruction and quantum circuits (in progress).\nAn environment for performing and building variational algorithms for matrix product states. Algorithms such as the density-matrix renormalization group are included by default.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This will remain in development until all the matrix product states functionality is concluded, along with support for CUDA. At that point we will release v1.0.0, and then add functionality for other tensor network methods, such as uniform matrix product states, tree tensor networks and projected-entangled pair states.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This documentation is styled in a way that we hope you can learn from example. However, we also provide afterwards a \"manual\" of sorts which details more advanced functionality.","category":"page"}]
}
